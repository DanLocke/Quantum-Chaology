# -*- coding: utf-8 -*-
"""
Created on Wed Sep 30 17:35:32 2015

2D infinite potential wells
@author: Dan Goldsmith & Dan Locke
"""
import numpy as np
from numpy import linalg
import matplotlib.pyplot as plt
import scipy.constants as sc
import QCfunctions as qcf

""" 
2D well labelled in following pattern:
  _____
 |1 2 3|
 |4 5 6|
 |_____|
"""
c = 30#int(input("Enter number of points in x axis: "))
r = 29#int(input("Enter number points in y axis: "))
x = 1.#float(input("Enter width (x axis) of well: "))
y = 1.#float(input("Enter depth (y axis) of well: "))
#state_x = 2#int(input("Enter energy state in x (GS=1): "))
#state_y = 1#int(input("Enter energy state in y (GS=1): "))

a = x/c # spacing in x axis
b = y/r # spacing in y axis
n = r*c

H = qcf.createMatrix(x,y,c,r)
w, v = linalg.eig(H)

# enumerate list and sort by eigenvalues, return index of relevant energy level
# here m labels mth energy level (in sorted list of energies)
m=0
state_ind = sorted(enumerate(w), key=lambda x: x[1])[m][0]#[len(s)+counter][0]

xt = np.linspace(0,x,c+2)
yt = np.linspace(0,y,r+2)
X, Y = np.meshgrid(xt, yt)
z = qcf.arrayFromZ(v[:,state_ind], c, r)
qcf.plot2Dpsi(X,Y,z,0)

state_x = 1#int(input("Enter energy state in x (GS=1): "))
state_y = 1#int(input("Enter energy state in y (GS=1): "))

ansatz = ( (2/np.sqrt(x*y))*np.sin((state_x)*np.pi*X/x)*np.sin((state_y)*np.pi*Y/y) )**2
Ix=[]
for i in range(0,c+1):
    Ix.append(scipy.integrate.simps(z[i,:], x=xt))
    
I = scipy.integrate.simps(Ix, x=yt)
z=z/I
qcf.plot2Dpsi(X,Y,z,ansatz)



# Energy
En = (w[state_ind]/2)
print('Energy is', En)
# Analytical solution (normalised)
ans_E = (( (state_x*np.pi*b/c)**2+(state_y*np.pi*a/r)**2 )*0.5 )
print('Ansatz energy is', ans_E)

Et = []
for i in range(1,c+1):
    for j in range(1,r+1):
        Et.append(( (i*np.pi*b/c)**2+(j*np.pi*a/r)**2 )*0.5 )
        
nt = np.linspace(1,n,n)
E = sorted(w/2)
Et = sorted(Et)
qcf.plotEnergies(nt, E, Et)
